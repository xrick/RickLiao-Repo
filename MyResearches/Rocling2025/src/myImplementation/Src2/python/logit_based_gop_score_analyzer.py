# -*- coding: utf-8 -*-
"""Logit-Based GOP Score Analyzer (Python Script)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DqjKrRpQtZ5F53kLCn6CE36siezdP5MO
"""

# -*- coding: utf-8 -*-
"""
Logit-Based GOP Score Analyzer (Python Script)

This script reproduces the core functionalities described in the paper
"Evaluating Logit-Based GOP Scores for Mispronunciation Detection".
It takes an audio file and a corresponding transcript (in ARPAbet phonemes)
as input, performs forced alignment using a CTC-based model, and calculates
five different Goodness of Pronunciation (GOP) scores for each phoneme.

Requirements:
- Python 3.8+
- PyTorch
- Transformers
- Librosa
- NumPy
- CTC-Segmentation
- Rich

You can install the necessary packages using pip:
pip install torch transformers librosa numpy ctc-segmentation rich

Usage:
python gop_analyzer.py --audio <path_to_audio_file> --transcript "p h o n e m e s"

Example:
python gop_analyzer.py --audio ./my_audio.wav --transcript "hh ah l ow w er l d"
"""

import argparse
import torch
import librosa
import numpy as np
from transformers import Wav2Vec2ForCTC, Wav2Vec2Processor
from ctc_segmentation import ctc_segmentation, Char_Timing
from rich.console import Console
from rich.table import Table
from rich.progress import Progress

# --- Constants ---
MODEL_NAME = "facebook/wav2vec2-xlsr-53-espeak-cv-ft"
TARGET_SAMPLE_RATE = 16000

# --- GOP Calculator Module ---
class GOPCalculator:
    """
    A collection of static methods to calculate various GOP scores from logits.
    """
    alpha = 0.5  # As defined in the paper for GOP_Combined

    @staticmethod
    def _softmax(x: np.ndarray) -> np.ndarray:
        """Compute softmax values for each sets of scores in x."""
        e_x = np.exp(x - np.max(x, axis=1, keepdims=True))
        return e_x / e_x.sum(axis=1, keepdims=True)

    @staticmethod
    def calculate_gop_dnn(logits_slice: np.ndarray, target_id: int) -> float:
        """Calculates the traditional DNN-based GOP score."""
        if logits_slice.shape[0] == 0:
            return -np.inf
        probabilities = GOPCalculator._softmax(logits_slice)
        target_probs = probabilities[:, target_id]
        mean_prob = np.mean(target_probs)
        # Avoid log(0)
        return -np.log(mean_prob + 1e-9)

    @staticmethod
    def calculate_gop_maxlogit(logits_slice: np.ndarray, target_id: int) -> float:
        """Calculates the GOP score based on the maximum logit."""
        if logits_slice.shape[0] == 0:
            return -np.inf
        target_logits = logits_slice[:, target_id]
        return np.max(target_logits)

    @staticmethod
    def calculate_gop_margin(logits_slice: np.ndarray, target_id: int) -> float:
        """Calculates the GOP score based on the logit margin."""
        if logits_slice.shape[0] == 0:
            return -np.inf
        target_logits = logits_slice[:, target_id]

        # Create a mask to exclude the target logit
        mask = np.ones(logits_slice.shape[1], dtype=bool)
        mask[target_id] = False

        # Get max competitor logit for each frame
        competitor_logits = logits_slice[:, mask]
        max_competitor_logits = np.max(competitor_logits, axis=1)

        margins = target_logits - max_competitor_logits
        return np.mean(margins)

    @staticmethod
    def calculate_gop_varlogit(logits_slice: np.ndarray, target_id: int) -> float:
        """Calculates the GOP score based on the logit variance."""
        if logits_slice.shape[0] == 0:
            return -np.inf
        target_logits = logits_slice[:, target_id]
        return np.var(target_logits)

    @staticmethod
    def calculate_gop_combined(gop_margin: float, gop_dnn: float) -> float:
        """Calculates the combined GOP score."""
        return GOPCalculator.alpha * gop_margin - (1 - GOPCalculator.alpha) * gop_dnn

# --- Main Application Logic ---
def main():
    """
    Main function to run the GOP analysis from the command line.
    """
    parser = argparse.ArgumentParser(description="Logit-Based GOP Score Analyzer")
    parser.add_argument("--audio", type=str, required=True, help="Path to the audio file.")
    parser.add_argument("--transcript", type=str, required=True, help="Space-separated ARPAbet transcript.")
    args = parser.parse_args()

    console = Console()

    with Progress(console=console) as progress:
        task_load = progress.add_task("[cyan]Loading model...", total=1)

        # 1. Load Model and Processor
        try:
            processor = Wav2Vec2Processor.from_pretrained(MODEL_NAME)
            model = Wav2Vec2ForCTC.from_pretrained(MODEL_NAME)
            progress.update(task_load, advance=1, description="[green]Model loaded.")
        except Exception as e:
            console.print(f"[bold red]Error loading model: {e}[/bold red]")
            return

        # 2. Load and Process Audio
        task_audio = progress.add_task("[cyan]Processing audio...", total=1)
        try:
            waveform, sample_rate = librosa.load(args.audio, sr=TARGET_SAMPLE_RATE)
            progress.update(task_audio, advance=1, description="[green]Audio processed.")
        except Exception as e:
            console.print(f"[bold red]Error processing audio file: {e}[/bold red]")
            return

        # 3. Perform Inference
        task_infer = progress.add_task("[cyan]Performing inference...", total=1)
        with torch.no_grad():
            input_values = processor(waveform, return_tensors="pt", sampling_rate=TARGET_SAMPLE_RATE).input_values
            logits = model(input_values).logits.squeeze(0).cpu().numpy()
        progress.update(task_infer, advance=1, description="[green]Inference complete.")

        # 4. Perform CTC Segmentation (Forced Alignment)
        task_align = progress.add_task("[cyan]Aligning phonemes...", total=1)

        # Prepare for ctc-segmentation
        ground_truth_text = args.transcript.lower().replace(" ", "|")
        vocab = processor.tokenizer.get_vocab()
        # The ctc-segmentation library expects a dictionary mapping characters to integer indices.
        # It also requires a blank token, which is typically at index 0 for CTC models.
        char_list = [""] * len(vocab)
        for char, index in vocab.items():
            char_list[index] = char

        config = Char_Timing(char_list=char_list,
                             blank_id=processor.tokenizer.pad_token_id,
                             space_id=-1) # No space token in this phoneme set

        try:
            timings = ctc_segmentation(config, logits, ground_truth_text)
            progress.update(task_align, advance=1, description="[green]Alignment complete.")
        except Exception as e:
            console.print(f"[bold red]Error during alignment: {e}[/bold red]")
            console.print("[yellow]This can happen if the audio and transcript are highly mismatched.[/yellow]")
            return

        # 5. Calculate GOP Scores for each segment
        results = []
        frame_duration = model.config.inputs_to_logits_ratio / TARGET_SAMPLE_RATE
        phoneme_to_id = {v: k for k, v in enumerate(char_list)}

        for seg in timings.segments:
            if not seg.label or seg.label == processor.tokenizer.pad_token:
                continue

            target_id = phoneme_to_id.get(seg.label)
            if target_id is None:
                continue

            start_frame, end_frame = seg.start, seg.end
            logits_slice = logits[start_frame:end_frame]

            if logits_slice.shape[0] == 0:
                continue

            gop_dnn = GOPCalculator.calculate_gop_dnn(logits_slice, target_id)
            gop_maxlogit = GOPCalculator.calculate_gop_maxlogit(logits_slice, target_id)
            gop_margin = GOPCalculator.calculate_gop_margin(logits_slice, target_id)
            gop_varlogit = GOPCalculator.calculate_gop_varlogit(logits_slice, target_id)
            gop_combined = GOPCalculator.calculate_gop_combined(gop_margin, gop_dnn)

            results.append({
                "phoneme": seg.label,
                "start_time": seg.start * frame_duration,
                "end_time": seg.end * frame_duration,
                "gop_dnn": gop_dnn,
                "gop_maxlogit": gop_maxlogit,
                "gop_margin": gop_margin,
                "gop_varlogit": gop_varlogit,
                "gop_combined": gop_combined,
            })

    # 6. Display Results
    table = Table(title="[bold]GOP Analysis Results[/bold]")
    table.add_column("Phoneme", style="cyan", no_wrap=True)
    table.add_column("Start (s)", style="magenta")
    table.add_column("End (s)", style="magenta")
    table.add_column("GOP_DNN", style="green")
    table.add_column("GOP_MaxLogit", style="yellow")
    table.add_column("GOP_Margin", style="blue")
    table.add_column("GOP_VarLogit", style="red")
    table.add_column("GOP_Combined", style="purple")

    if not results:
        console.print("[yellow]Could not extract any valid phoneme segments.[/yellow]")
        return

    for res in results:
        table.add_row(
            res["phoneme"],
            f"{res['start_time']:.3f}",
            f"{res['end_time']:.3f}",
            f"{res['gop_dnn']:.3f}",
            f"{res['gop_maxlogit']:.3f}",
            f"{res['gop_margin']:.3f}",
            f"{res['gop_varlogit']:.3f}",
            f"{res['gop_combined']:.3f}",
        )

    console.print(table)

if __name__ == "__main__":
    main()